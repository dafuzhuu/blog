[{"content":"OLS回归的步骤如下\n$$ \\mathbf{R}_i = \\mathbf{X}_i \\mathbf{b}_i + \\boldsymbol{\\epsilon}_i $$ 其中\n$$\\mathbf{R}_i = \\begin{pmatrix} R_{i1}^e \\\\ R_{i2}^e \\\\ \\vdots \\\\ R_{iT}^e\\\\ \\end{pmatrix}_{T\\times 1}, \\mathbf{X}_i = \\begin{pmatrix} 1 \u0026amp; \\lambda_1^T \\\\ 1 \u0026amp; \\lambda_2^T \\\\ \\vdots \u0026amp; \\vdots \\\\ 1 \u0026amp; \\lambda_T^T \\end{pmatrix}_{T \\times (k+1)}, \\mathbf{b}_i = \\begin{pmatrix} \\alpha_i \\\\ \\beta_i \\end{pmatrix}_{(k+1) \\times 1}, \\boldsymbol{\\epsilon}_i = \\begin{pmatrix} \\epsilon_{i1} \\\\ \\epsilon_{i2} \\\\ \\vdots \\\\ \\epsilon_{iT} \\end{pmatrix}_{T\\times 1} $$\n我们希望通过最小化误差平方和来估计 $\\mathbf{b}_i$，即最小化以下目标函数：\n$$ S(\\mathbf{b}_i) = \\sum_{t=1}^T \\epsilon_{it}^2 = \\boldsymbol{\\epsilon}_i^T \\boldsymbol{\\epsilon}_i $$\n其中 $\\boldsymbol{\\epsilon}_i = \\mathbf{R}_i - \\mathbf{X}_i \\mathbf{b}_i$，所以我们可以将目标函数写为：\n$$ S(\\mathbf{b}_i) = (\\mathbf{R}_i - \\mathbf{X}_i \\mathbf{b}_i)^2 = (\\mathbf{R}_i - \\mathbf{X}_i \\mathbf{b}_i)^T (\\mathbf{R}_i - \\mathbf{X}_i \\mathbf{b}_i) $$\n展开后得到：\n$$ S(\\mathbf{b}_i) = \\mathbf{R}_i^T \\mathbf{R}_i - 2\\mathbf{b}_i^T \\mathbf{X}_i^T \\mathbf{R}_i + \\mathbf{b}_i^T \\mathbf{X}_i^T \\mathbf{X}_i \\mathbf{b}_i $$\n为了找到最小值，我们需要对 $S(\\mathbf{b}_i)$ 关于 $\\mathbf{b}_i$ 求导并令其等于零：\n$$ \\frac{\\partial S(\\mathbf{b}_i)}{\\partial \\mathbf{b}_i} = -2\\mathbf{X}_i^T \\mathbf{R}_i + 2\\mathbf{X}_i^T \\mathbf{X}_i \\mathbf{b}_i = 0 $$\n简化后得到：\n$$ \\mathbf{X}_i^T \\mathbf{X}_i \\mathbf{b}_i = \\mathbf{X}_i^T \\mathbf{R}_i $$\n由于 $\\mathbf{X}_i^T \\mathbf{X}_i$ 是可逆的（假设不存在多重共线性），我们可以得到：\n$$ \\hat{\\mathbf{b}}_i = (\\mathbf{X}_i^T \\mathbf{X}_i)^{-1} \\mathbf{X}_i^T \\mathbf{R}_i $$\n$\\hat{\\mathbf{b}}_i$ 是回归系数的估计值，包括 $\\hat{\\alpha}_i$ 和 $\\hat{\\beta}_i$：\n$$ \\hat{\\mathbf{b}}_i = \\begin{pmatrix} \\hat{\\alpha}_i \\\\ \\hat{\\beta}_i \\end{pmatrix} $$\n误差项 $\\epsilon_{it}$ 的估计值可以通过以下公式得到：\n$$ \\hat{\\boldsymbol{\\epsilon}}_i = \\mathbf{R}_i - \\mathbf{X}_i \\hat{\\mathbf{b}}_i $$\n","permalink":"http://localhost:1313/blog/chapters/ols%E5%9B%9E%E5%BD%92/","summary":"OLS回归的步骤如下\n$$ \\mathbf{R}_i = \\mathbf{X}_i \\mathbf{b}_i + \\boldsymbol{\\epsilon}_i $$ 其中\n$$\\mathbf{R}_i = \\begin{pmatrix} R_{i1}^e \\\\ R_{i2}^e \\\\ \\vdots \\\\ R_{iT}^e\\\\ \\end{pmatrix}_{T\\times 1}, \\mathbf{X}_i = \\begin{pmatrix} 1 \u0026amp; \\lambda_1^T \\\\ 1 \u0026amp; \\lambda_2^T \\\\ \\vdots \u0026amp; \\vdots \\\\ 1 \u0026amp; \\lambda_T^T \\end{pmatrix}_{T \\times (k+1)}, \\mathbf{b}_i = \\begin{pmatrix} \\alpha_i \\\\ \\beta_i \\end{pmatrix}_{(k+1) \\times 1}, \\boldsymbol{\\epsilon}_i = \\begin{pmatrix} \\epsilon_{i1} \\\\ \\epsilon_{i2} \\\\ \\vdots \\\\ \\epsilon_{iT} \\end{pmatrix}_{T\\times 1} $$\n我们希望通过最小化误差平方和来估计 $\\mathbf{b}_i$，即最小化以下目标函数：\n$$ S(\\mathbf{b}_i) = \\sum_{t=1}^T \\epsilon_{it}^2 = \\boldsymbol{\\epsilon}_i^T \\boldsymbol{\\epsilon}_i $$","title":"OLS回归"},{"content":"SSH（Secure Shell）公钥是用于在网络通信中实现安全身份验证的一种加密方式。\nSSH原理 非对称加密：SSH公钥认证使用非对称加密技术，这种技术涉及一对密钥：公钥和私钥。\n公钥（Public Key）：可以公开发布，任何人都可以获取。 私钥（Private Key）：必须严格保密，只能由密钥的拥有者持有。 加密与解密：\n加密：公钥用于加密数据。由于公钥是公开的，任何人都可以使用它加密信息。 解密：只有对应的私钥可以解密由公钥加密的信息。这确保了只有密钥的拥有者（持有私钥的人）才能读取加密内容。 身份验证过程：\n生成密钥对：用户首先在本地设备上生成一对公钥和私钥。 上传公钥：用户将公钥上传到需要访问的远程服务器（如GitHub、远程Linux服务器）。 私钥保密：私钥保存在用户的本地设备上，不与任何人共享。 连接与认证：\n当用户尝试通过SSH连接到远程服务器时，服务器会生成一个随机数并使用用户的公钥对其加密，然后将加密后的数据发送给用户。 用户的SSH客户端使用本地的私钥解密服务器发送的加密数据。 如果解密成功，用户客户端将解密结果发回给服务器。 服务器验证解密结果是否正确，以确认用户持有相应的私钥。如果正确，身份验证通过。 确保安全：\n安全性：由于私钥从不在网络上传输，攻击者无法通过截获通信数据来获取私钥。 防篡改：即使攻击者获取了公钥，无法伪装成合法用户，因为他们没有对应的私钥。 优势：\n高安全性：相比传统的用户名/密码认证，SSH公钥认证更加安全，因为私钥不会在网络上传输，并且密钥对是独一无二的。 无密码登录：SSH公钥认证允许无密码的自动化登录，便于脚本、自动化工具和日常运维。 管理便捷：可以为每个设备或用户设置不同的公钥，并且可以随时管理和撤销。 如何设置SSH 生成SSH密钥 打开终端并输入以下命令来生成新的SSH密钥：\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 当系统提示时，按回车键以接受默认的文件路径（通常是 ~/.ssh/id_ed25519）。\n接着，系统会要求你设置一个密码短语。你可以选择设置，也可以直接按回车跳过。\n添加SSH密钥到SSH代理 启动SSH代理：\neval \u0026#34;$(ssh-agent -s)\u0026#34; 将生成的SSH密钥添加到SSH代理中：\nssh-add ~/.ssh/id_ed25519 将SSH密钥添加到GitHub 查看你的SSH公钥：\ncat ~/.ssh/id_ed25519.pub 然后复制输出的内容。 SSH公钥的格式通常是一个单行的文本字符串，包含了三部分内容：加密类型、加密公钥数据和注释（通常是你的邮箱地址）。以下是一个典型的SSH公钥格式示例：\nssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIG8sVpP8h65X8+8Km6BtJQG9d8gY6J7sZ+TpJQeV9XZT your_email@example.com 登录GitHub，前往 Settings -\u0026gt; SSH and GPG keys -\u0026gt; New SSH key。\n在 \u0026ldquo;Title\u0026rdquo; 中输入一个名称（如 \u0026ldquo;My Computer\u0026rdquo;），并将复制的SSH公钥粘贴到 \u0026ldquo;Key\u0026rdquo; 字段中，最后点击 Add SSH key。\n使用SSH方式克隆仓库 现在你可以使用SSH URL来克隆GitHub仓库了： git clone git@github.com:username/repository.git SSH的应用 我有两台电脑，但一般只会随身携带一台，所以我需要在两台电脑上的本地同步博客文件夹的信息，等价于在两台电脑上都能pull和push博客所在的GitHub仓库，从而实现同步。我需要在两台电脑上生成并上传SSH公钥。\n","permalink":"http://localhost:1313/blog/articles/set_ssh/","summary":"SSH（Secure Shell）公钥是用于在网络通信中实现安全身份验证的一种加密方式。\nSSH原理 非对称加密：SSH公钥认证使用非对称加密技术，这种技术涉及一对密钥：公钥和私钥。\n公钥（Public Key）：可以公开发布，任何人都可以获取。 私钥（Private Key）：必须严格保密，只能由密钥的拥有者持有。 加密与解密：\n加密：公钥用于加密数据。由于公钥是公开的，任何人都可以使用它加密信息。 解密：只有对应的私钥可以解密由公钥加密的信息。这确保了只有密钥的拥有者（持有私钥的人）才能读取加密内容。 身份验证过程：\n生成密钥对：用户首先在本地设备上生成一对公钥和私钥。 上传公钥：用户将公钥上传到需要访问的远程服务器（如GitHub、远程Linux服务器）。 私钥保密：私钥保存在用户的本地设备上，不与任何人共享。 连接与认证：\n当用户尝试通过SSH连接到远程服务器时，服务器会生成一个随机数并使用用户的公钥对其加密，然后将加密后的数据发送给用户。 用户的SSH客户端使用本地的私钥解密服务器发送的加密数据。 如果解密成功，用户客户端将解密结果发回给服务器。 服务器验证解密结果是否正确，以确认用户持有相应的私钥。如果正确，身份验证通过。 确保安全：\n安全性：由于私钥从不在网络上传输，攻击者无法通过截获通信数据来获取私钥。 防篡改：即使攻击者获取了公钥，无法伪装成合法用户，因为他们没有对应的私钥。 优势：\n高安全性：相比传统的用户名/密码认证，SSH公钥认证更加安全，因为私钥不会在网络上传输，并且密钥对是独一无二的。 无密码登录：SSH公钥认证允许无密码的自动化登录，便于脚本、自动化工具和日常运维。 管理便捷：可以为每个设备或用户设置不同的公钥，并且可以随时管理和撤销。 如何设置SSH 生成SSH密钥 打开终端并输入以下命令来生成新的SSH密钥：\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 当系统提示时，按回车键以接受默认的文件路径（通常是 ~/.ssh/id_ed25519）。\n接着，系统会要求你设置一个密码短语。你可以选择设置，也可以直接按回车跳过。\n添加SSH密钥到SSH代理 启动SSH代理：\neval \u0026#34;$(ssh-agent -s)\u0026#34; 将生成的SSH密钥添加到SSH代理中：\nssh-add ~/.ssh/id_ed25519 将SSH密钥添加到GitHub 查看你的SSH公钥：\ncat ~/.ssh/id_ed25519.pub 然后复制输出的内容。 SSH公钥的格式通常是一个单行的文本字符串，包含了三部分内容：加密类型、加密公钥数据和注释（通常是你的邮箱地址）。以下是一个典型的SSH公钥格式示例：\nssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIG8sVpP8h65X8+8Km6BtJQG9d8gY6J7sZ+TpJQeV9XZT your_email@example.com 登录GitHub，前往 Settings -\u0026gt; SSH and GPG keys -\u0026gt; New SSH key。\n在 \u0026ldquo;Title\u0026rdquo; 中输入一个名称（如 \u0026ldquo;My Computer\u0026rdquo;），并将复制的SSH公钥粘贴到 \u0026ldquo;Key\u0026rdquo; 字段中，最后点击 Add SSH key。","title":"使用SSH密钥进行身份验证"},{"content":"文章分为两种，一种为主干，另一种是分支。好的博文会将主干写的清晰简洁，而技术细节会放在分支里。在Hugo中，无论是主干还是分支都会显示在Archive中，这是我们不希望看见的。我们希望隐藏分支，在Archive中只看到主干文章，但仍能通过url访问到分支。\nHugo主文件夹中的 layouts 可以覆盖theme中的配置，因此可以将主题中 layouts/_default/archives.html 复制到主文件夹的 layouts 下，并进行修改。\n以PaperMod主题为例\n\u0026lt;div class=\u0026#34;archive-posts\u0026#34;\u0026gt; {{- range .Pages }} {{- if not .Params.hidden }} \u0026lt;!-- 添加hidden逻辑 --\u0026gt; {{- if eq .Kind \u0026#34;page\u0026#34; }} \u0026lt;div class=\u0026#34;archive-entry\u0026#34;\u0026gt; \u0026lt;h3 class=\u0026#34;archive-entry-title entry-hint-parent\u0026#34;\u0026gt; {{- .Title | markdownify }} {{- if .Draft }} \u0026lt;span class=\u0026#34;entry-hint\u0026#34; title=\u0026#34;Draft\u0026#34;\u0026gt; \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; height=\u0026#34;15\u0026#34; viewBox=\u0026#34;0 -960 960 960\u0026#34; fill=\u0026#34;currentColor\u0026#34;\u0026gt; \u0026lt;path d=\u0026#34;M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z\u0026#34; /\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/span\u0026gt; {{- end }} \u0026lt;/h3\u0026gt; \u0026lt;div class=\u0026#34;archive-meta\u0026#34;\u0026gt; {{- partial \u0026#34;post_meta.html\u0026#34; . -}} \u0026lt;/div\u0026gt; \u0026lt;a class=\u0026#34;entry-link\u0026#34; aria-label=\u0026#34;post link to {{ .Title | plainify }}\u0026#34; href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; {{- end }} {{- end }} {{- end }} \u0026lt;!-- 隐藏 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; Hugo对于非默认的章节参数都会存储在 .Params 下面，通过\n{{- if not .Params.hidden }} ... {{- end }} 可以隐藏 hidden = true 的文章，使其不显示在Archive中\n+++ title = \u0026#39;隐藏文章\u0026#39; date = 2024-08-31T10:38:24+08:00 draft = false hidden = true +++ ","permalink":"http://localhost:1313/blog/articles/sub_articles/","summary":"文章分为两种，一种为主干，另一种是分支。好的博文会将主干写的清晰简洁，而技术细节会放在分支里。在Hugo中，无论是主干还是分支都会显示在Archive中，这是我们不希望看见的。我们希望隐藏分支，在Archive中只看到主干文章，但仍能通过url访问到分支。\nHugo主文件夹中的 layouts 可以覆盖theme中的配置，因此可以将主题中 layouts/_default/archives.html 复制到主文件夹的 layouts 下，并进行修改。\n以PaperMod主题为例\n\u0026lt;div class=\u0026#34;archive-posts\u0026#34;\u0026gt; {{- range .Pages }} {{- if not .Params.hidden }} \u0026lt;!-- 添加hidden逻辑 --\u0026gt; {{- if eq .Kind \u0026#34;page\u0026#34; }} \u0026lt;div class=\u0026#34;archive-entry\u0026#34;\u0026gt; \u0026lt;h3 class=\u0026#34;archive-entry-title entry-hint-parent\u0026#34;\u0026gt; {{- .Title | markdownify }} {{- if .Draft }} \u0026lt;span class=\u0026#34;entry-hint\u0026#34; title=\u0026#34;Draft\u0026#34;\u0026gt; \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; height=\u0026#34;15\u0026#34; viewBox=\u0026#34;0 -960 960 960\u0026#34; fill=\u0026#34;currentColor\u0026#34;\u0026gt; \u0026lt;path d=\u0026#34;M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z\u0026#34; /\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/span\u0026gt; {{- end }} \u0026lt;/h3\u0026gt; \u0026lt;div class=\u0026#34;archive-meta\u0026#34;\u0026gt; {{- partial \u0026#34;post_meta.","title":"Hugo设置文章隐藏功能"},{"content":"","permalink":"http://localhost:1313/blog/chapters/grs/","summary":"","title":"GRS"},{"content":"Math Matrix Algebra for Engineers Advanced Linear Algebra Differential Equations for Engineers Vector Calculus for Engineers Mathematics for Engineers: The Capstone Course Introduction to Complex Analysis Combinatorics and Probability Stochastic Processes: Data Analysis and Computer Simulation Bayesian Statistics Statistical Learning Machine Learning with Python-From Linear Models to Deep Learning Fundamentals of Quantitative Modeling Introduction to Predictive Modeling Discrete Optimization Optimization for Decision Making Advanced Models for Decision Making Simulation Models for Decision Making Operations Research (1): Models and Applications Operations Research (2): Optimization Algorithms Operations Research (3): Theory Analytic Combinatorics Mathematical Thinking Mathematical Thinking in Computer Science Number Theory and Cryptography Delivery Problem Computer Science CS50\u0026rsquo;s Introduction to Computer Science Object-Oriented Data Structures in C++ Algorithmic Toolbox Ordered Data Structures Unordered Data Structures Introduction to Git and GitHub CS 61B Spring 2024 Data Structures Algorithms on Graphs Algorithms on Strings Advanced Algorithms and Complexity Introduction to Graph Theory Divide and Conquer, Sorting and Searching, and Randomized Algorithms Graph Search, Shortest Paths, and Data Structures Greedy Algorithms, Minimum Spanning Trees, and Dynamic Programming Shortest Paths Revisited, NP-Complete Problems and What To Do About Them Probabilistic Graphical Models 1: Representation Probabilistic Graphical Models 2: Inference Probabilistic Graphical Models 3: Learning Deep Neural Networks with PyTorch Natural Language Processing with Classification and Vector Spaces Text Retrieval and Search Engines Text Mining and Analytics Applied Text Mining in Python Pattern Discovery in Data Mining Cluster Analysis in Data Mining 李宏毅2023春机器学习 Fundamentals of Reinforcement Learning Sample-based Learning Methods Prediction and Control with Function Approximation A Complete Reinforcement Learning System (Capstone) Reinforcement Learning: Qwik Start Applied Plotting, Charting \u0026amp; Data Representation in Python Narrative Economics Social and Economic Networks Applied Social Network Analysis in Python Tools of the Trade: Linux and SQL Finance Introduction to Financial Engineering and Risk Management Interest Rate Models Pricing Options with Mathematical Models Term-Structure and Credit Derivatives Optimization Methods in Asset Management Advanced Topics in Derivative Pricing Computational Methods in Pricing and Model Calibration 机器学习与量化投资（复旦） Elective Courses Applying to U.S. Universities JPMorgan量化项目 Digital Signal Processing Specialization FinTech Foundations and Overview Text Generation with Markov Chains in Python The Finite Element Method for Problems in Physics Introduction to Recommender Systems: Non-Personalized and Content-Based Nearest Neighbor Collaborative Filtering Recommender Systems: Evaluation and Metrics Matrix Factorization and Advanced Techniques Recommender Systems Capstone 其他 概率论与统计学 动手学深度学习 机器学习白板推导 动手学强化学习 MIT深度学习 Gil的矩阵论 Stanford的最优化 Manim Julia编程 hello算法 测度论与概率论 实变函数：陈闯（川大） 随机过程：张颢（清华） 抽象代数 泛函分析 转码路线图 快速入门量化 Programming Methodology Operating Systems Principles Deep Learning Book 金融工程 王树森：深度强化学习 CS231n：CV CS224n：NLP [前10节入门（必做），后面的选做] 邱锡鹏：神经网络与深度学习 MIT矩阵微积分 MIT6.824分布式系统 复变函数：国立清华 Topics In Mathematics With Applications In Finance Advanced Stochastic Processes Point Set Topology 上交《动手学大模型》 Machine learning for algorithmic trading Quantitative Primer Quant Roadmap 学长推荐：学一下海外的正经机构是如何做投资的，从顶层思路构建、到策略设计、到风控 ","permalink":"http://localhost:1313/blog/articles/study_plan/","summary":"Math Matrix Algebra for Engineers Advanced Linear Algebra Differential Equations for Engineers Vector Calculus for Engineers Mathematics for Engineers: The Capstone Course Introduction to Complex Analysis Combinatorics and Probability Stochastic Processes: Data Analysis and Computer Simulation Bayesian Statistics Statistical Learning Machine Learning with Python-From Linear Models to Deep Learning Fundamentals of Quantitative Modeling Introduction to Predictive Modeling Discrete Optimization Optimization for Decision Making Advanced Models for Decision Making Simulation Models for Decision Making Operations Research (1): Models and Applications Operations Research (2): Optimization Algorithms Operations Research (3): Theory Analytic Combinatorics Mathematical Thinking Mathematical Thinking in Computer Science Number Theory and Cryptography Delivery Problem Computer Science CS50\u0026rsquo;s Introduction to Computer Science Object-Oriented Data Structures in C++ Algorithmic Toolbox Ordered Data Structures Unordered Data Structures Introduction to Git and GitHub CS 61B Spring 2024 Data Structures Algorithms on Graphs Algorithms on Strings Advanced Algorithms and Complexity Introduction to Graph Theory Divide and Conquer, Sorting and Searching, and Randomized Algorithms Graph Search, Shortest Paths, and Data Structures Greedy Algorithms, Minimum Spanning Trees, and Dynamic Programming Shortest Paths Revisited, NP-Complete Problems and What To Do About Them Probabilistic Graphical Models 1: Representation Probabilistic Graphical Models 2: Inference Probabilistic Graphical Models 3: Learning Deep Neural Networks with PyTorch Natural Language Processing with Classification and Vector Spaces Text Retrieval and Search Engines Text Mining and Analytics Applied Text Mining in Python Pattern Discovery in Data Mining Cluster Analysis in Data Mining 李宏毅2023春机器学习 Fundamentals of Reinforcement Learning Sample-based Learning Methods Prediction and Control with Function Approximation A Complete Reinforcement Learning System (Capstone) Reinforcement Learning: Qwik Start Applied Plotting, Charting \u0026amp; Data Representation in Python Narrative Economics Social and Economic Networks Applied Social Network Analysis in Python Tools of the Trade: Linux and SQL Finance Introduction to Financial Engineering and Risk Management Interest Rate Models Pricing Options with Mathematical Models Term-Structure and Credit Derivatives Optimization Methods in Asset Management Advanced Topics in Derivative Pricing Computational Methods in Pricing and Model Calibration 机器学习与量化投资（复旦） Elective Courses Applying to U.","title":"Coursera自学指南"},{"content":"原书pdf: 《因子投资 方法与实践》\n回归检验 时间序列回归 对某只股票 $i$\n$$ R_{it}^e=\\alpha_i+\\beta_i^T\\lambda_t+\\epsilon_t, \\quad t=1,2,\\cdots,T $$\n时序回归：首先固定$i$，以这只股票在不同时间上的数据为样本，做OLS回归，得到属于这只股票的$\\beta_i^T,\\alpha_i,\\epsilon_i$。\n这是一张散点图，横轴是用时序回归估计出来的 $\\hat{\\beta}_i$ ，纵轴是通过公式 $E_t[R_{it}^e]=\\hat{\\alpha}_i+\\hat{\\beta}_iE_t[\\lambda_t]$ 估计出来的预期收益率。因此，这张图不是最小化 $\\alpha_i$ 的结果。\n既然我们已经估计出 $\\alpha_i$，下面要检验其是否联合为零。常用的方法是GRS检验。\n","permalink":"http://localhost:1313/blog/posts/factor_invest/","summary":"原书pdf: 《因子投资 方法与实践》\n回归检验 时间序列回归 对某只股票 $i$\n$$ R_{it}^e=\\alpha_i+\\beta_i^T\\lambda_t+\\epsilon_t, \\quad t=1,2,\\cdots,T $$\n时序回归：首先固定$i$，以这只股票在不同时间上的数据为样本，做OLS回归，得到属于这只股票的$\\beta_i^T,\\alpha_i,\\epsilon_i$。\n这是一张散点图，横轴是用时序回归估计出来的 $\\hat{\\beta}_i$ ，纵轴是通过公式 $E_t[R_{it}^e]=\\hat{\\alpha}_i+\\hat{\\beta}_iE_t[\\lambda_t]$ 估计出来的预期收益率。因此，这张图不是最小化 $\\alpha_i$ 的结果。\n既然我们已经估计出 $\\alpha_i$，下面要检验其是否联合为零。常用的方法是GRS检验。","title":"因子投资慢读计划"},{"content":"from jqfactor import get_factor_values, neutralize, winsorize_med, standardlize from jqfactor import Factor, calc_factors import datetime import pandas as pd import numpy as np import matplotlib.pyplot as plt import statsmodels.api as sm from scipy.stats import spearmanr,pearsonr import matplotlib.pyplot as plt import matplotlib.dates as mdates import copy import time plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] # 用来正常显示中文标签 plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False # 用来正常显示负号 获取数据 获取交易日 输入：start_date（起始日期），end_date（终止日期），freq（频率），count（None）\n# 1.1-获取交易日 def get_calendar(start_date=None, end_date=None, freq=\u0026#39;D\u0026#39;, count=None): \u0026#34;\u0026#34;\u0026#34; params: start_date(Timestamp)：起始日期，年月日 end_date(Timestamp)：终止日期，年月日 freq(str)：交易日频率，默认每天 - \u0026#39;W\u0026#39;: 每周 - \u0026#39;M\u0026#39;: 每月 - \u0026#39;Q\u0026#39;: 每季度 - \u0026#39;Y\u0026#39;: 每年 count(int)：获取终止日期前交易日数量 return: df.index(DatetimeIndex)：交易日索引列表 \u0026#34;\u0026#34;\u0026#34; # 调整时间格式 start = pd.to_datetime(start_date) end = pd.to_datetime(end_date) # 时间区间 if count != None: df = get_price(\u0026#39;000001.XSHG\u0026#39;, end_date=end, count=count) else: df = get_price(\u0026#39;000001.XSHG\u0026#39;, start_date=start, end_date=end) # 时间周期 end_day = df.index df[freq] = df.index.to_period(freq).start_time end_day = df.groupby(freq).apply(lambda x: x.index.max()) return pd.to_datetime(end_day.values) # 例子 start = \u0026#34;20230101\u0026#34; end = \u0026#34;20231231\u0026#34; get_calendar(start, end, freq=\u0026#39;M\u0026#39;) 输出\nDatetimeIndex([\u0026#39;2023-01-31\u0026#39;, \u0026#39;2023-02-28\u0026#39;, \u0026#39;2023-03-31\u0026#39;, \u0026#39;2023-04-28\u0026#39;, \u0026#39;2023-05-31\u0026#39;, \u0026#39;2023-06-30\u0026#39;, \u0026#39;2023-07-31\u0026#39;, \u0026#39;2023-08-31\u0026#39;, \u0026#39;2023-09-28\u0026#39;, \u0026#39;2023-10-31\u0026#39;, \u0026#39;2023-11-30\u0026#39;, \u0026#39;2023-12-29\u0026#39;], dtype=\u0026#39;datetime64[ns]\u0026#39;, freq=None) 筛选股票函数 剔除\nST股 次新股 开盘涨跌停股（可选） # 1.2-筛选股票函数 def filter_stock(stock_list, date, days=21*3, limit=1): \u0026#34;\u0026#34;\u0026#34; params: stock_list (list)：股票序列列表，[\u0026#34;600000.XSHG\u0026#34;, ...] date (Timestamp)：交易日，年月日 days (int)：过滤次新股时间 limit (int)：过滤涨跌停开关，1/0 return: stock_list (list)：过滤后的股票序列列表，[\u0026#34;600000.XSHG\u0026#34;, ...] \u0026#34;\u0026#34;\u0026#34; date = pd.to_datetime(date) # 除上市距beginDate不足3个月的股票 def _delete_new(stocks, begin_date, n=days): filtered_list = [] for stock in stocks: start_date = get_security_info(stock).start_date if start_date \u0026lt; (begin_date - pd.Timedelta(days=n)).date(): filtered_list.append(stock) return filtered_list # 剔除ST股 st_data = get_extras(\u0026#39;is_st\u0026#39;, stock_list, count=1, end_date=date) stock_list = [stock for stock in stock_list if not st_data[stock][0]] # 剔除次新股 stock_list = _delete_new(stock_list, date, n=days) # 剔除开盘涨停股票 if limit == 1: df = get_price(stock_list, end_date=date, fields=[\u0026#39;open\u0026#39;, \u0026#39;high_limit\u0026#39;, \u0026#39;low_limit\u0026#39;], count=1, skip_paused=True, panel=False) df = df.set_index(\u0026#34;code\u0026#34;) df[\u0026#39;h_limit\u0026#39;] = (df[\u0026#39;open\u0026#39;] != df[\u0026#39;high_limit\u0026#39;]) df[\u0026#39;l_limit\u0026#39;] = (df[\u0026#39;open\u0026#39;] != df[\u0026#39;low_limit\u0026#39;]) # 过滤开盘涨跌停股票 stock_list = [i for i in df.index if (df.loc[i, \u0026#34;h_limit\u0026#34;] and df.loc[i, \u0026#34;l_limit\u0026#34;])] return stock_list # 例子 stockList = list(map(normalize_code, [\u0026#34;301136\u0026#34;, \u0026#34;000586\u0026#34;, \u0026#34;300125\u0026#34;])) # 301136为2022-01-11上市 print(\u0026#34;剔除次新股：\u0026#34;, filter_stock(stockList, \u0026#34;20220102\u0026#34;)) # 300125在2024-06-10为ST股 print(\u0026#34;剔除ST股：\u0026#34;, filter_stock(stockList, \u0026#34;20240610\u0026#34;)) # 000586在2024-08-07开盘涨停 print(\u0026#34;剔除开盘涨跌停股：\u0026#34;, filter_stock(stockList, \u0026#34;20240807\u0026#34;)) 输出\n剔除次新股： [\u0026#39;000586.XSHE\u0026#39;, \u0026#39;300125.XSHE\u0026#39;] 剔除ST股： [\u0026#39;301136.XSHE\u0026#39;, \u0026#39;000586.XSHE\u0026#39;] 剔除开盘涨跌停股： [\u0026#39;301136.XSHE\u0026#39;] 获取因子值函数 joinquant中有两类因子：因子库、定义因子\n文档：\n因子库 定义因子 其中因子库为joinquant内置，输入字符串即可获取。定义因子是继承Factor类后自己定义的因子，本质上是一个子类。\n# 1.3-获取因子值函数，必须全部为聚宽因子或全部为定义因子 # 可以分别获取后再合并 def get_factor_df(stock_list, factor_list, date): \u0026#34;\u0026#34;\u0026#34; params: stock_list(list)：股票序列列表，[\u0026#34;600000.XSHG\u0026#34;,...] factor_list(list)：因子名称列表，[\u0026#34;residual_volatility\u0026#34;,...] date(Timestamp)：交易日，年月日（取前一日的因子值） return: df(DataFrame)：因子数据集，pd.DataFrame(index=[stock_list], columns=[factor_list]) \u0026#34;\u0026#34;\u0026#34; date = pd.to_datetime(date) # 取前一天的数据 last_date = get_near_trade_day(date, -1) if type(factor_list[0]) == str: factor_data = get_factor_values(securities=stock_list, factors=factor_list, end_date=last_date, count=1) # 如果是定义因子像ep()这种，需要因子计算 else: factor_data = calc_factors(securities=stock_list, factors=factor_list, start_date=last_date, end_date=last_date, use_real_price=False, skip_paused=True) factor_list = [factor.name for factor in factor_list] df = pd.concat([pd.DataFrame(factor_data[f]).T for f in factor_list], axis=1) df.columns = factor_list return df # 例子 stock_list = list(map(normalize_code, [\u0026#34;301136\u0026#34;, \u0026#34;000586\u0026#34;, \u0026#34;300125\u0026#34;])) factor_list = [\u0026#34;beta\u0026#34;, \u0026#34;size\u0026#34;, \u0026#34;momentum\u0026#34;] get_factor_df(stock_list, factor_list, \u0026#34;20240701\u0026#34;) 输出\ncode beta size momentum 301136.XSHE 2.435321 -2.257106 -1.057598 000586.XSHE 2.069847 -2.969061 -1.214831 300125.XSHE 2.515297 -4.036516 -3.761750 获取每期股票对应的因子值和收益率 输入日期，因子，以及股票池；对每天的因子值进行去极值（winsorize）、行业市值中性化（neutralize）、标准化（standardlize），至此因子预处理完成。\n接着考虑下期收益率。不存在滞后算子时（lag=0）\n$$ R_t=\\frac{P_{t+1}}{P_t} $$\n若引入滞后算子$i\\neq 0$，则\n$$ R_t^i=\\frac{P_{t+1+i}}{P_t} $$\n所以如果时间序列为 $t_1,t_2,t_3,t_4,t_5$，则lag=0时收益率数据只有四个$R_1,R_2,R_3,R_4$，lag=1时只有三个$R_1^1,R_2^1,R_3^1$，以此类推。\n(len(date_list) - 1) - i - 1 \u0026lt; lag_i 左式为结束日期到当前日期的距离，右式为收益率跨度\n验证：当lag_i = 0时，到最后一个时间点，即 i=(len(date_list)-1)-1，此时0\u0026lt;0=False，存在即期收益率，正确。\n# 1.4-获取每期股票对应的因子值和收益率 def get_fac_ret_dict(date_list, factor_list, index_code=None, lag_num=5): \u0026#34;\u0026#34;\u0026#34; params: date_list (list)：交易日列表 factor_list (list)：因子名称列表，如 [\u0026#34;residual_volatility\u0026#34;, ...] index_code (str)：指数代码，表示股票池，None 表示全市场池 lag_num (int)：收益率延期期数，方便后续计算因子 IC 半衰期 return: dict：因子数据集的时间字典，格式为 {date: pd.DataFrame(index=[stock_list], columns=[factor_list + yield])} \u0026#34;\u0026#34;\u0026#34; data_dict = {} lag_num_list = list(range(lag_num + 1)) # 删掉最后一期（需要下期收益率） for i in range(len(date_list) - 1): day = date_list[i] # 选择股票池 pool = get_index_stocks(index_code, day) if index_code else get_all_securities(date=day).index # 过滤股票 pool = filter_stock(pool, day) # 获取因子数据 df = get_factor_df(pool, factor_list, day).dropna(axis=0, how=\u0026#39;any\u0026#39;) pool = df.index.tolist() # 异常值处理：中位数法 df = winsorize_med(df, scale=3, inclusive=True, inf2nan=True, axis=0) # 行业市值中性化 df = neutralize(df, how=[\u0026#39;sw_l1\u0026#39;, \u0026#39;market_cap\u0026#39;], date=day, axis=0) # 标准化 df = standardlize(df, inf2nan=True, axis=0) # 获取当天价格 price = get_price(pool, count=1, end_date=day, skip_paused=True, panel=False, fields=[\u0026#39;close\u0026#39;])[\u0026#39;close\u0026#39;] # 计算延期收益率（每个lag单独算） for lag_i in lag_num_list: # 剩余天数不足lag，用0填充 if (len(date_list) - 1) - i \u0026lt; lag_i + 1: df[lag_i] = np.zeros(len(pool)) else: next_day = date_list[i + 1 + lag_i] next_price = get_price(pool, count=1, end_date=next_day, skip_paused=True, panel=False, fields=[\u0026#39;close\u0026#39;])[\u0026#39;close\u0026#39;] df[lag_i] = next_price.values / price.values - 1 data_dict[day] = df return data_dict # 例子 date_list = get_calendar(end=\u0026#34;20240807\u0026#34;, count=60, freq=\u0026#39;W\u0026#39;) factor_list = [\u0026#34;beta\u0026#34;, \u0026#34;size\u0026#34;, \u0026#34;momentum\u0026#34;] index_code = \u0026#39;000300.XSHG\u0026#39; fac_ret_dict = get_fac_ret_dict(date_list, factor_list, index_code) date = date_list[5] print(f\u0026#34;{date} 因子值和收益率\u0026#34;) fac_ret_dict[date].head() 输出\n2024-06-21 00:00:00 因子值和收益率\ncode beta size momentum 0 1 2 3 4 5 000001.XSHE 0.716460 0.569768 -0.579750 0.015000 -0.003000 0.031000 0.037000 0.003000 0.014000 000002.XSHE 0.640406 0.438910 -0.987371 -0.036161 -0.043115 -0.033380 -0.018081 -0.048679 -0.052851 000063.XSHE 1.509532 1.183595 -0.655145 0.000366 -0.016850 0.023443 0.029670 -0.013553 -0.025275 000100.XSHE -0.755233 0.651778 0.740881 0.018868 -0.004717 0.009434 -0.061321 -0.087264 -0.091981 000157.XSHE -0.559411 -0.672491 0.715088 -0.026596 -0.063830 -0.057181 -0.074468 -0.102394 -0.125000 因子有效性测试 IC测试 IC衡量预测变量的预测能力，其定义通常为$t+1$时刻的预测收益率与真实收益率在截面上的相关系数。\n实操中，$t+1$时刻的预测收益率常用$t$时刻的预测变量代替（也就是因子值）\n# 2.1 因子IC测试 def factor_IC_test(_fac_ret_dict, _factor_list): date_list = list(_fac_ret_dict.keys()) IC_df = pd.DataFrame(0, index=date_list, columns=_factor_list) IC_stats_df = pd.DataFrame(0, index=[\u0026#34;IC_mean\u0026#34;, \u0026#34;IC_std\u0026#34;, \u0026#34;IR\u0026#34;, \u0026#34;sig_prop\u0026#34;, \u0026#34;t-value\u0026#34;], columns=_factor_list) for date in date_list: for factor in _factor_list: fac_ret_df = _fac_ret_dict[date][[factor, 0]] ic, p_value = spearmanr(fac_ret_df.loc[:, factor], fac_ret_df.loc[:, 0]) IC_df.loc[date, factor] = ic IC_stats_df.loc[\u0026#34;IC_mean\u0026#34;] = IC_df.mean(axis=0) IC_stats_df.loc[\u0026#34;IC_std\u0026#34;] = IC_df.std(axis=0) IC_stats_df.loc[\u0026#34;IR\u0026#34;] = IC_df.mean(axis=0) / IC_df.std(axis=0) IC_stats_df.loc[\u0026#34;sig_prop\u0026#34;] = np.sum(np.abs(IC_df) \u0026gt; 0.02, axis=0) / np.count_nonzero(IC_df, axis=0) IC_stats_df.loc[\u0026#34;t-value\u0026#34;] = IC_df.mean(axis=0) / IC_df.std(axis=0) * np.sqrt(len(IC_df)) return IC_df, IC_stats_df # 例子 IC_df, IC_stats_df = factor_IC_test(fac_ret_dict, factor_list) IC_df.head() 输出\nDate beta size momentum 2024-05-17 -0.208500 0.056870 0.114491 2024-05-24 -0.106488 -0.011449 -0.013559 2024-05-31 -0.274823 0.185290 0.313269 2024-06-07 0.136722 -0.059606 -0.052470 2024-06-14 -0.184472 0.152148 0.299300 IC_stats_df 输出\nbeta size momentum IC_mean -0.058974 0.022510 0.025554 IC_std 0.141956 0.095083 0.184682 IR -0.415435 0.236741 0.138367 sig_prop 1.000000 0.833333 0.916667 t-value -1.439109 0.820095 0.479318 因子分组并计算组合收益率 需要IC测试判断因子和收益率相关性的正负，再分组并构建投资组合\n# 2.2-因子分组并计算投资组合收益率 def get_group_portfolio_dict(_data_dict, _factor_list, neg_corr_fac_list, group_num=5, weight_method=\u0026#34;avg\u0026#34;, index_code=\u0026#34;000300.XSHG\u0026#34;): \u0026#34;\u0026#34;\u0026#34; params: _data_dict(dict)：因子值数据集的时间字典，{date：pd.DataFrame(index=[stock_list], columns=[_factor_list + yield(0)])} _factor_list(list)：因子名称列表，[\u0026#34;residual_volatility\u0026#34;,...] neg_corr_fac_list(list)：与收益率为负相关的因子名称列表 group_num(int)：因子分组的组数，其中第0组为不分组 weight_method(str)：投资组合股票权重类型 index_code(str): 基准指数 return: group_factor_dict(dict): 分组因子值数据集的时间字典，{date：pd.DataFrame(columns=[group_num])} group_yield_dict(dict): 分组股票收益率数据集的时间字典，{date：pd.DataFrame(columns=[group_num])} portfolio_yield_dict(dict): 分组投资组合收益率的时间字典， {date：pd.DataFrame(index=[date], columns=[0 + group_num + index + long_short])} \u0026#34;\u0026#34;\u0026#34; date_list = list(_data_dict.keys()) # 初始化字典：分组后的因子暴露和股票收益率 group_factor_dict = dict.fromkeys(_factor_list) group_yield_dict = dict.fromkeys(_factor_list) for factor in _factor_list: # 每个value是新的字典 {date: None} group_factor_dict[factor] = dict([(k, None) for k in date_list]) group_yield_dict[factor] = dict([(k, None) for k in date_list]) # 初始化字典：投资组合的收益率 group_list = list(range(group_num + 1)) # 0代表不分组 portfolio_yield_dict = {} for factor in _factor_list: portfolio_yield_dict[factor] = pd.DataFrame(data=None, index=date_list, columns=group_list) # 遍历每个时间点的因子值\u0026amp;资产收益率 for date, data in _data_dict.items(): # 遍历每个因子 for factor in _factor_list: # 如果因子与收益负相关 is_ascending = factor in neg_corr_fac_list # 若IC\u0026lt;0, 则升序排列；若IC\u0026gt;0, 则降序排列（收益率理应更高的股票排在前面） all_stock = data.sort_values(factor, ascending=is_ascending).index lens = len(all_stock) # 无法被组数整除的部分用nan填充 nan_num = np.full(group_num - lens % group_num, np.nan) # 股票分组，不足的补全nan值（用reshape分组） all_stock_filled = np.append(all_stock, nan_num) group_stock = all_stock_filled.reshape((group_num, -1)).T # 股票收益率分组 yield_ = data.loc[list(all_stock), 0].values yield_filled = np.append(yield_, nan_num) group_yield = yield_filled.reshape((group_num, -1)).T # 股票因子值分组 factor_ = data.loc[list(all_stock), factor].values factor_filled = np.append(factor_, nan_num) group_factor = factor_filled.reshape((group_num, -1)).T # 分组后股票对应因子和对应收益率 group_factor_dict[factor][date] = pd.DataFrame(data=group_factor, columns=group_list[1:]) group_yield_dict[factor][date] = pd.DataFrame(data=group_yield, columns=group_list[1:]) if weight_method == \u0026#34;mktcap\u0026#34;: # 分组后市值加权投资组合收益率 size_ = get_factor_values(securities=list(all_stock), factors=[\u0026#34;market_cap\u0026#34;], end_date=date, count=1)[\u0026#34;market_cap\u0026#34;] size0 = size0.applymap(lambda x: x ** -0.333).values # 照顾小市值 size_filled = np.append(size_, nan_num) size_grouped = size_filled.reshape((group_num, -1)).T # 将市值分组，得到每组市值 # 不分组，整体的收益 portfolio = np.nansum(yield_ * (size_ / np.nansum(size_))) # 分组，每组的收益（组内的股票共用一个权重） portfolio_group = np.nansum(group_yield * (size_grouped / np.nansum(size_grouped, axis=0)), axis=0) # columns=[0, 1, 2, ..., n], with n groups portfolio_yield_dict[factor].loc[date, :] = np.append(portfolio, portfolio_group) else: # 分组后等权投资组合收益率 portfolio = np.nanmean(yield_) portfolio_group = np.nanmean(group_yield, axis=0) portfolio_yield_dict[factor].loc[date, :] = np.append(portfolio, portfolio_group) # 将未分组、指数、多空组合统计进入投资组合中 # date_list(_data_dict的键)删减了最后一个交易日，计算收益率需要补回来 end_date = get_near_trade_day(date_list[-1], 1) index_price = get_price(index_code, start_date=date_list[0], end_date=end_date, skip_paused=True, panel=False, fields=[\u0026#39;open\u0026#39;]) date_list.append(end_date) index_price = index_price.loc[date_list, \u0026#34;open\u0026#34;] for factor in _factor_list: portfolio_yield_dict[factor][\u0026#34;index\u0026#34;] = (index_price / index_price.shift(1)).dropna(axis=0, how=\u0026#39;any\u0026#39;).values - 1 # 第一组 - 最后一组 portfolio_yield_dict[factor][\u0026#34;long_short\u0026#34;] = portfolio_yield_dict[factor][1] - portfolio_yield_dict[factor][group_num] return group_factor_dict, group_yield_dict, portfolio_yield_dict # 例子 data_dict = fac_ret_dict.copy() factor_list = factor_list.copy() neg_corr_fac_list = [\u0026#34;beta\u0026#34;] group_factor_dict, group_yield_dict, portfolio_yield_dict = get_group_portfolio_dict(data_dict, factor_list, neg_corr_fac_list) print(f\u0026#34;group_factor_dict: beta, {date_list[5]}\u0026#34;) group_factor_dict[\u0026#34;beta\u0026#34;][date_list[5]].head(10) # row as stocks(not the same in each row!), column as groups 输出\ngroup_factor_dict: beta, 2024-06-21 00:00:00\n1 2 3 4 5 0 -3.127815 -0.782981 -0.220503 0.241513 0.899368 1 -2.608957 -0.777437 -0.217409 0.263952 0.905673 2 -2.466028 -0.771171 -0.213984 0.270753 0.906024 3 -2.379335 -0.770582 -0.209276 0.295320 0.926811 4 -2.236061 -0.755233 -0.204300 0.318216 0.939260 5 -2.146409 -0.753317 -0.200050 0.318709 0.942325 6 -2.138083 -0.748938 -0.196521 0.328538 0.945144 7 -1.982549 -0.728641 -0.196068 0.352257 0.968289 8 -1.951236 -0.672973 -0.195188 0.358029 0.974325 9 -1.912529 -0.669878 -0.190616 0.370640 0.985332 print(f\u0026#34;group_yield_dict: beta, {date_list[5]}\u0026#34;) group_yield_dict[\u0026#34;beta\u0026#34;][date_list[5]].head(10) 输出\ngroup_yield_dict: beta, 2024-06-21 00:00:00\n1 2 3 4 5 0 0.015873 -0.054359 0.015328 0.005828 -0.004678 1 -0.029513 0.015817 -0.017335 0.054304 -0.030735 2 -0.038543 -0.097788 0.025758 0.003311 -0.072949 3 -0.059705 -0.009297 -0.072324 0.011792 -0.039123 4 0.056701 0.018868 -0.053505 -0.033629 -0.011364 5 -0.004926 -0.024651 -0.072303 0.013011 -0.063488 6 0.060438 0.042201 0.040793 0.053456 0.007519 7 -0.020833 -0.081037 -0.095761 -0.035380 -0.101844 8 -0.010228 0.048269 -0.039514 -0.073384 -0.038304 9 -0.063094 0.000000 0.013255 -0.039593 -0.027425 print(f\u0026#34;portfolio_yield_dict: beta\u0026#34;) portfolio_yield_dict[\u0026#34;beta\u0026#34;] 输出\nDate 0 1 2 3 4 5 index long_short 2024-05-17 -0.0212019 -0.0212385 -0.0172659 -0.0110899 -0.024375 -0.0330077 -0.002124 0.0117692 2024-05-24 -0.0026993 -0.00157968 5.88723e-05 0.00493396 -0.014688 -0.00217902 -0.008541 0.00059934 2024-05-31 -0.00422427 0.0113847 -0.00175829 0.000561831 -0.0162851 -0.0159888 -0.001442 0.0273735 2024-06-07 -0.00109651 -0.00648105 -0.00998194 6.14662e-05 7.22157e-05 0.0119131 -0.022208 -0.0183942 2024-06-14 -0.0165621 -0.00675819 -0.016695 -0.0076833 -0.0241726 -0.0284781 -0.005252 0.0217199 2024-06-21 -0.0169605 -0.012736 -0.010357 -0.0100194 -0.0143996 -0.0391058 -0.015064 0.0263698 2024-06-28 -0.0133534 -0.0159938 -0.00656651 -0.00745181 -0.0158852 -0.0215409 -0.000090 0.00554702 2024-07-05 0.0163921 0.0105308 0.0197113 0.00671937 0.0250903 0.0202228 0.004821 -0.00969201 2024-07-12 0.0231685 0.0313948 0.0179932 0.015852 0.0219193 0.0291754 0.011806 0.00221932 2024-07-19 -0.0316384 -0.0362365 -0.0269216 -0.0324149 -0.0317956 -0.0307507 -0.027736 -0.00548579 2024-07-26 -0.000504842 -0.00238374 -0.0017709 -0.00674665 -0.00465131 0.0142367 -0.002876 -0.0166205 2024-08-02 -0.00884012 -0.00919352 -0.0124423 -0.00690704 -0.00256224 -0.0134754 -0.009373 0.0042819 plot_return(portfolio_yield_dict[\u0026#34;beta\u0026#34;]) 工具函数 def get_near_trade_day(date, count): \u0026#34;\u0026#34;\u0026#34; 获取相邻的交易日。 参数: date (Timestamp)：当天交易日，年月日。 count (int)：交易日相隔数，负数代表前，正数代表后。 返回: Timestamp：上一个或下一个交易日，年月日。 \u0026#34;\u0026#34;\u0026#34; # 获取上一个交易日 if count \u0026lt; 0: df = get_price(\u0026#39;000001.XSHG\u0026#39;, end_date=date, count=abs(count) + 1) return df.index[0] # 获取下一个交易日 elif count \u0026gt; 0: df = get_price(\u0026#39;000001.XSHG\u0026#39;, start_date=date, end_date=datetime.date.today()) return df.index[count] # 如果 count == 0，返回原日期 return date def plot_return(df): \u0026#34;\u0026#34;\u0026#34; 绘制收益率曲线图 params: df(dataframe): 每日收益率数据，pd.DataFrame(index=[dates], columns=[portfolios]) \u0026#34;\u0026#34;\u0026#34; num_ticks = 12 plt.figure(figsize=(18,6)) cum_return = (1 + df).cumprod() - 1 for col in df.columns: plt.plot(df.index, cum_return[col] * 100, label=col) dates = pd.to_datetime(df.index, unit=\u0026#34;ms\u0026#34;) ticks = np.linspace(0, len(dates) - 1, num_ticks, dtype=int) plt.xticks(dates[ticks]) plt.gca().xaxis.set_major_formatter(mdates.DateFormatter(\u0026#39;%Y-%m-%d\u0026#39;)) plt.gcf().autofmt_xdate() plt.legend() plt.show() # 计时器 def count_time(func, *args, number): start_time = time.time() for _ in range(number): func(*args) end_time = time.time() return end_time - start_time 不足之处 借用了JoinQuant平台的内置函数，只能在平台上运行，对内存、算力等有限制，自由度太低 目前只实现了基本的因子测试部分（IC，long-short），更多功能有 测试部分加上FSC，t统计量指标 缺少Fama-MacBeth等回归（结合石川因子投资） 缺少组合优化和选股 Python运行速度很慢 下阶段将重点研究\n更多因子投资方法 将以上框架用DolphinDB实现 将新的因子投资方法用DolphinDB实现 预计10月前完成。因子框架完成后在筹码分布上测试，连接到筹码这部分只需把计算筹码数据和筹码因子的函数换成DolphinDB语言，工作量不大，同期可以记录些筹码因子的idea\n参考文献 因子研究框架—收益模型篇 自定义python库 《因子投资 - 方法与实践》 API文档 因子库 因子分析（定义因子） ","permalink":"http://localhost:1313/blog/posts/factor_framework/","summary":"from jqfactor import get_factor_values, neutralize, winsorize_med, standardlize from jqfactor import Factor, calc_factors import datetime import pandas as pd import numpy as np import matplotlib.pyplot as plt import statsmodels.api as sm from scipy.stats import spearmanr,pearsonr import matplotlib.pyplot as plt import matplotlib.dates as mdates import copy import time plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] # 用来正常显示中文标签 plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False # 用来正常显示负号 获取数据 获取交易日 输入：start_date（起始日期），end_date（终止日期），freq（频率），count（None）\n# 1.1-获取交易日 def get_calendar(start_date=None, end_date=None, freq=\u0026#39;D\u0026#39;, count=None): \u0026#34;\u0026#34;\u0026#34; params: start_date(Timestamp)：起始日期，年月日 end_date(Timestamp)：终止日期，年月日 freq(str)：交易日频率，默认每天 - \u0026#39;W\u0026#39;: 每周 - \u0026#39;M\u0026#39;: 每月 - \u0026#39;Q\u0026#39;: 每季度 - \u0026#39;Y\u0026#39;: 每年 count(int)：获取终止日期前交易日数量 return: df.","title":"基于JoinQuant的因子回测框架"},{"content":"在刷题的过程中，积累单词、句式、语法，在做阅读的时候为写作整理素材，在做听力的时候为口语准备语料，这样才能融会贯通，而不是盲人摸象。\n生词 Word Meaning onwards adv. 从\u0026hellip;起 excavate v. 挖掘 coinage n. 创造新词的动作 portmanteau term n. 合成词，portmanteau 综合的 hoof/hooves n. 蹄/蹄子（复数） rear v. 抚养，养育 padded adj. 带衬垫的 pugnosed adj. 鼻子扁平的 elaborate adj. 复杂的 , v. 详述 succulent adj. 多汁的 grind v. 磨碎 abrasive adj./n. 研磨的 fusion n. 融合 subsistence n. 维持生计 carp n. 鲤鱼 scoop v. 舀 porcelains n. 瓷器 fairs n. 集市 sheer adj. 纯粹的 insulate v. 隔绝 reptile n. 爬行动物 feat n. 壮举，成就 bask v. 晒太阳，取暖 长难句理解 \u0026#x2705; TPO75 Reading The Palaces of Minoan Crete\nFrom the early twentieth-century work of archaeologist Arthur Evans onwards, the ingrained and embedded religious nature of the palaces has been accepted, as has the fact that \u0026ldquo;palace\u0026rdquo; is inadequate shorthand for the buildings\u0026rsquo; complexities.\n这里提到从20世纪初考古学家Arthur Evans的工作开始，人们已经接受了这些宫殿内在的宗教性质，并且认识到“palace”这个词不足以概括这些建筑的复杂性。\n\u0026ldquo;has been accepted\u0026rdquo; 没有出现accept的主体，\u0026ldquo;as has the fact that\u0026rdquo; 故技重施，也是被accept的对象\nAccurate terminology that did not privilege one function over another would require the coinage of a portmanteau term such as \u0026ldquo;palace-temple” or \u0026ldquo;temple-palace,” but this seems an undesirable deviation from terminology that is long established, whatever its shortcomings.\n如果要精确描述而不偏向任何一种功能，就需要创造出类似于“palace-temple”或“temple-palace”这样的混合词汇，但这似乎是对长期以来已确立术语的不必要偏离。\n\u0026ldquo;did not privilege one function over another\u0026rdquo; 是个很漂亮的写法，\nprivilege A over B，等价于prefer A to B，consider A more important than B\n\u0026#x2705;TPO74 The Commercialization of Pearl River Agriculture\n这篇特别多坑\nPeasant farmers produced on their own plots much of the food the family consumed.\n主干：farmers produced food\n","permalink":"http://localhost:1313/blog/articles/toefl%E5%88%B7%E9%A2%98/","summary":"在刷题的过程中，积累单词、句式、语法，在做阅读的时候为写作整理素材，在做听力的时候为口语准备语料，这样才能融会贯通，而不是盲人摸象。\n生词 Word Meaning onwards adv. 从\u0026hellip;起 excavate v. 挖掘 coinage n. 创造新词的动作 portmanteau term n. 合成词，portmanteau 综合的 hoof/hooves n. 蹄/蹄子（复数） rear v. 抚养，养育 padded adj. 带衬垫的 pugnosed adj. 鼻子扁平的 elaborate adj. 复杂的 , v. 详述 succulent adj. 多汁的 grind v. 磨碎 abrasive adj./n. 研磨的 fusion n. 融合 subsistence n. 维持生计 carp n. 鲤鱼 scoop v. 舀 porcelains n. 瓷器 fairs n. 集市 sheer adj. 纯粹的 insulate v. 隔绝 reptile n.","title":"TOEFL刷题积累"},{"content":"假定你的电脑已安装好Hugo，本文档可以逐行跑通，是从零开始搭建Hugo博客的简易指南\n本地搭建Hugo博客 hugo new site theplaybook --format yaml cd theplaybook 用hugo new site [博客文件夹名称]指令在当前目录下新建一个Hugo模版。--format [配置文件格式]可选的格式有yaml, toml（默认toml）\nhugo new docs/test.md git clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 git init git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod hugo new docs/test.md会在/content/docs下新建一个md文件test.md\n随后用git导入主题PaperMod，这两句足够完成配置，更多信息见Hugo PaperMod\nvim hugo.yaml 按\u0026quot;I\u0026quot;(Insert)开始编辑，删除baseURL的内容，并在最后一行下面添加\ntheme: PaperMod 按Esc再输入:wq保存并退出编辑\n至此Hugo博客在本地的搭建已经完成，运行hugo server指令并在网址栏输入localhost:1313就可以在本地看到博客的界面\n将Hugo部署到Github Pages GitHub Pages可用于免费托管静态网站，并且会分配一个像样的域名，比购买国内服务器和域名并备案要经济得多\n首先在创建一个GitHub账号，新建一个仓库theplaybook-demo，保持默认配置项即可（Public仓库+不添加README）\n步骤1: 在终端运行仓库主页代码\necho \u0026#34;# theplaybook-demo\u0026#34; \u0026gt;\u0026gt; README.md git add README.md git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/dafuzhuu/theplaybook-demo.git git push -u origin main 步骤2: 手动添加gh-pages分支\n步骤3: 接着在Settings下的Actions/General里，滑到最下面，打开Read and Write Permissions\n步骤4: 在Pages下的Build and deployment，将Source更换为GitHub Actions\n步骤5: 添加workflow\n导航到博客文件夹根目录\nmkdir -p .github/workflows touch .github/workflows/hugo.yaml vim .github/workflows/hugo.yaml 接着将下面代码复制到.github/workflows/hugo.yaml\n# Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: - main # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued. # However, do NOT cancel in-progress runs as we want to allow these production deployments to complete. concurrency: group: \u0026#34;pages\u0026#34; cancel-in-progress: false # Default to bash defaults: run: shell: bash jobs: # Build job build: runs-on: ubuntu-latest env: HUGO_VERSION: 0.128.0 steps: - name: Install Hugo CLI run: | wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\ \u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb - name: Install Dart Sass run: sudo snap install dart-sass - name: Checkout uses: actions/checkout@v4 with: submodules: recursive fetch-depth: 0 - name: Setup Pages id: pages uses: actions/configure-pages@v5 - name: Install Node.js dependencies run: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34; - name: Build with Hugo env: HUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache HUGO_ENVIRONMENT: production TZ: America/Los_Angeles run: | hugo \\ --gc \\ --minify \\ --baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34; - name: Upload artifact uses: actions/upload-pages-artifact@v3 with: path: ./public # Deployment job deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest needs: build steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4 步骤6: 上传到GitHub\ngit add . git commit -m \u0026#34;Add workflow\u0026#34; git push ","permalink":"http://localhost:1313/blog/posts/demo/","summary":"假定你的电脑已安装好Hugo，本文档可以逐行跑通，是从零开始搭建Hugo博客的简易指南\n本地搭建Hugo博客 hugo new site theplaybook --format yaml cd theplaybook 用hugo new site [博客文件夹名称]指令在当前目录下新建一个Hugo模版。--format [配置文件格式]可选的格式有yaml, toml（默认toml）\nhugo new docs/test.md git clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 git init git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod hugo new docs/test.md会在/content/docs下新建一个md文件test.md\n随后用git导入主题PaperMod，这两句足够完成配置，更多信息见Hugo PaperMod\nvim hugo.yaml 按\u0026quot;I\u0026quot;(Insert)开始编辑，删除baseURL的内容，并在最后一行下面添加\ntheme: PaperMod 按Esc再输入:wq保存并退出编辑\n至此Hugo博客在本地的搭建已经完成，运行hugo server指令并在网址栏输入localhost:1313就可以在本地看到博客的界面\n将Hugo部署到Github Pages GitHub Pages可用于免费托管静态网站，并且会分配一个像样的域名，比购买国内服务器和域名并备案要经济得多\n首先在创建一个GitHub账号，新建一个仓库theplaybook-demo，保持默认配置项即可（Public仓库+不添加README）\n步骤1: 在终端运行仓库主页代码\necho \u0026#34;# theplaybook-demo\u0026#34; \u0026gt;\u0026gt; README.md git add README.md git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.","title":"15分钟用Hugo+Github Pages搭建博客"}]